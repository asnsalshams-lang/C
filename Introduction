# Print Helo world #
--------------------
#include <stdio.h>
int main ()
{
printf("Helo world\n");
return 0;
}

combile :
1. chmod +x file.c
2. cc file.c
3. ./a.out

Escape sequence
---------------
\n → newline
\t → tab
\\ → backslash
\" → double quote
\b → backspace

Variables And Arithatic Expressions
==================================
While loop
----------
#include <stdio.h>
/* print Fahrenheit-Celsius table
for fahr = 0, 20, ..., 300; floating-point version */
int main()
{
float fahr, celsius;     #variable decralaration
float lower, upper, step;  #variable decralaration

/* assign values to varables */
lower = 0;   
upper = 300;
step  = 20;
fahr = lower;

while (fahr <= upper){
celsius = (5.0/9.0)*(fahr-32.0);
printf("%.0f \t %.2f\n", fahr, celsius);
fahr = fahr + step;
}
}
========
For loop
=========
1. Execute init ONCE
2. Jump to cond
3. If cond == false → exit loop
4. Execute body
5. Execute step
6. Jump back to cond


#include <stdio.h>
/* print Fahrenheit-Celsius table */
int main(){

int fahr;

for(fahr = 0; fahr<=300; fahr = fahr + 20){
        printf("%3d %6.1f\n", fahr, (5.0/9.0)*(fahr-32));

}
}

putchar() and getchar()
----------------------
getchar(): Reads one single character from standard input (usually keyboard). Returns it as an int (important – handles all char values plus EOF, which is -1). If end-of-file or error, returns EOF.
putchar(): Writes one single character to standard output (usually screen). Takes an int (the char value) and outputs it.

#echo porgram by putchar and getchar#
#include <stdio.h>

int main() {
    int c;

/*------------------------------------(c = getchar()) != EOF ✅ - parentheses protect the assignment, do it first
c = getchar() != EOF ❌ - != grabs getchar() first, c gets true/false
Think of parentheses like putting a fence around the assignment to keep != away from it!
Without parentheses: c = getchar() != EOF

The != operator is stronger (higher precedence)
So != "grabs" or "steals" getchar() first
It becomes: c = (getchar() != EOF)
Result: c gets true/false (1 or 0)

With parentheses: (c = getchar()) != EOF

The parentheses protect =
So = gets getchar() first (assignment happens)
Then != compares c to EOF
Result: c gets the actual character
---------------------------------------------*/

    while ((c = getchar()) != EOF) {
        putchar(c);
    }
    return 0;
}

==========
1.6 Array
==========
1st issue:
Type: Out-of-Bounds Array Access (Undefined Behavior)
Impact: Reads uninitialized / unintended stack memory, leading to unpredictable output
Root Cause: Incorrect loop bounds and invalid index usage

#include <stdio.h>
int main(){
int c, i, nwhite, nother;
int ndigit[10];

nwhite = nother = 0;

for(i=0; i<=10; ++i)  ----------------
        ndigit[i] = 0;

while((c=getchar()) != EOF)
        if (c>=0 && c<= 9) ------------------------------------
                ++ndigit[c-'0'];
        else if (c==' ' || c=='\n' || c=='\t')
                ++nwhite;
        else
                ++nother;
printf("%d", ndigit[i]);  ------------------
}

why the output is 32751 when i enter 1 ??????????????????????????????????????????????????????????????
#####Root Causes###
Out-of-bounds access
The array ndigit[10] is valid only for indexes 0–9.
Using <= 10 in loops or printing ndigit[i] when i == 10 reads memory that does not belong to the array.
Wrong digit check
getchar() returns ASCII characters ('0'–'9'), not numeric values (0–9).
Checking c >= 0 && c <= 9 is always false for keyboard input.
C does no bounds checking
Writing or reading past array limits causes undefined behavior, not immediate errors.
Key Rules to Remember
Arrays in C do not track their size.
Loop bounds must be < size, not <= size.
Characters must be compared as characters ('0'–'9').
Never print or read an array using an index you didn’t explicitly control.
---------------------------------------------------------------------------------
-----#Correct code#-----
#include <stdio.h>

int main() {
    int c, i;
    int nwhite = 0, nother = 0;
    int ndigit[10];

    /* initialize array */
    for (i = 0; i < 10; ++i)
        ndigit[i] = 0;

    /* process input */
    while ((c = getchar()) != EOF) {
        if (c >= '0' && c <= '9')
            ++ndigit[c - '0'];
        else if (c == ' ' || c == '\n' || c == '\t')
            ++nwhite;
        else
            ++nother;
    }

    /* print digit counts */
    for (i = 0; i < 10; ++i)
        printf("digit %d: %d\n", i, ndigit[i]);

    return 0;
}

=============
1.7 Function
=============

multiply 2 values and assing to a memroy location +++++ get the result's location and the result value +++++++++++++++++
#include <stdio.h>

int squar(int x){
    return x * x;
}

int main(){
    int a = 2;
    int b = 6;
    int k = squar(a);
    int c = squar(b);

    printf("Addresses: &k=%p, &c=%p\n", (void*)&k, (void*)&c);
    printf("Values: k=%d, c=%d\n", k, c);

    return 0;
}
####################### Connection between function, arguement, Address and stack  ######################################
printf("Addresses: &k=%p, &c=%p\n", (void*)&k, (void*)&c); completely is not necssory!
printf("%p, %p", &k, &c) # others are for more understand, (void*)= Required for safe printing with %p (most compilers warn without it)
## In the result k is more higher value thean c ## because the stack grows downward ###

Each function call allocates one contiguous stack frame.
All stack-based local variables live inside that frame at fixed offsets.
The stack grows downward.
RSP only tracks the top of the stack.
CALL/RET and MOV instructions move data — not RSP by itself.
######################################################################################################################
