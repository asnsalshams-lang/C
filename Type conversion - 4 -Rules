C Standard: Integer Conversions (Line-by-Line)

This is what the compiler follows. Not intuition. Not â€œpriorityâ€. Rules.

STEP 0 â€” Terminology (you must know this)
Integer types (relevant here)

char / signed char / unsigned char

short / unsigned short

int / unsigned int

long / unsigned long

long long / unsigned long long

STEP 1 â€” Integer Promotions (happen FIRST)

Applies to:

Arithmetic

Comparisons

Function arguments (except variadic rules later)

Rule:

Any integer type smaller than int is promoted to:

int if int can represent all its values

otherwise unsigned int

Examples:
Original Type   | 	After Promotion
---------------------------------------
char	          |     int
signed char     |    	int
unsigned char	  |     int
short           |    	int
unsigned short	|     int (on most systems)

Example:

unsigned short s = 65535;
s + 1   // s â†’ int


ðŸš« This is NOT optional
ðŸš« This is NOT based on â€œpriorityâ€

STEP 2 â€” Usual Arithmetic Conversions

Once promotions are done, both operands must end up with the SAME TYPE.

The rules (in exact order):
Rule 1: Same type?

If both operands already have the same type â†’ use it.

int + int â†’ int
unsigned int + unsigned int â†’ unsigned int

Rule 5: Integer types only (THIS is your battlefield)

Now things get dangerous.

STEP 3 â€” Signed vs Unsigned Rules (CORE)

Let:

S = signed type

U = unsigned type

Case A â€” Unsigned rank â‰¥ signed rank

ðŸ‘‰ Signed converts to unsigned

Example:

unsigned int + int


int â†’ unsigned int

Negative values wrap

10u + (-20)
â†’ 10u + 4294967276u


ðŸ’¥ Classic bug source

Case B â€” Signed rank > unsigned rank

Check if signed type can represent all unsigned values.

If YES:

â†’ unsigned converts to signed

long + unsigned int


(on LP64 systems)

If NO:

â†’ both convert to unsigned version of signed type

unsigned long + long

STEP 4 â€” Comparisons use THE SAME RULES

This is where people screw up logic checks.

unsigned int u = 10;
int i = -20;

u < i


Conversions:

i â†’ unsigned int â†’ 4294967276
10 < 4294967276 â†’ TRUE


ðŸš¨ This breaks bounds checks

STEP 5 â€” Assignment Conversions

After expression evaluation:

int x = u + i;


Expression computed in unsigned

Then assigned to int

If out of range â†’ implementation-defined or wrap

STEP 6 â€” Variadic Functions (printf trap)
printf("%d", unsigned_int_value);

Important:

printf does ZERO conversions

It trusts the format string

It reinterprets bits

This is undefined behavior if types donâ€™t match.

ðŸš¨ %d expects int, not unsigned int

STEP 7 â€” Boolean Context (if, while)
if (unsigned_value < 0)


This is always false

Why?

0 is int

unsigned_value stays unsigned

0 â†’ unsigned

unsigned canâ€™t be negative

SUMMARY TABLE (MEMORIZE THIS)
Promotion Phase
Smaller than int	Promoted to
signed	int
unsigned	int (usually)
Mixed Signedness
Situation	Result
unsigned rank â‰¥ signed rank	signed â†’ unsigned
signed can represent unsigned	unsigned â†’ signed
otherwise	both â†’ unsigned
Red-Team Reality Check

Every one of these causes:

Heap overflows

Integer wrap bypasses

Length validation failures

CVEs

If you donâ€™t instantly see the conversion, youâ€™re exploitable.
