1. Integer Promotion (happens FIRST)
========================================
Before almost any operation, smaller integer types are promoted.

| Original Type    | Promoted To                                              |
| ---------------- | -------------------------------------------------------- |
| `char`           | `int` (or `unsigned int` if `int` can't hold all values) |
| `signed char`    | `int`                                                    |
| `unsigned char`  | `int`                                                    |
| `short`          | `int`                                                    |
| `unsigned short` | `int`                                                    |
| `enum`           | `int`                                                    |


#Hard rule#
------------
If int can represent all values ‚Üí promote to int
Otherwise ‚Üí unsigned int

üìå Reality check: On modern systems, int can hold all of these ‚Üí they become int.

--------------------------------------------------------------------------------

2. Usual Arithmetic Conversions (Binary Ops)

After promotion, both operands are converted to a common type.
Step-by-step decision table
| Case | Condition                                 | Resulting Type |
| ---- | ----------------------------------------- | -------------- |
| 1    | Both same type                            | No change      |
| 2    | One is `long double`                      | `long double`  |
| 3    | One is `double`                           | `double`       |
| 4    | One is `float`                            | `float`        |
| 5    | Both integers ‚Üí apply integer rules below | ‚¨á              |


3. Integer Conversion Rules (MOST IMPORTANT)
===========================================
This is where bugs live.
Same Signedness

| Types                            | Result          |
| -------------------------------- | --------------- |
| `int` + `long`                   | `long`          |
| `unsigned int` + `unsigned long` | `unsigned long` |

Larger type wins.

Mixed Signed & Unsigned
-------------------------
| Rule                                                | Explanation                            |
| --------------------------------------------------- | -------------------------------------- |
| Unsigned wins if it can represent all signed values | Signed ‚Üí Unsigned                      |
| Otherwise                                           | Both ‚Üí Unsigned version of signed type |

Practical table (32-bit example)

| Expression             | Conversion      | Why                                     |
| ---------------------- | --------------- | --------------------------------------- |
| `int + unsigned int`   | `unsigned int`  | Same width, unsigned wins               |
| `long + unsigned int`  | `long`          | `long` can represent all `unsigned int` |
| `int + unsigned long`  | `unsigned long` | `unsigned long` can't fit into `int`    |
| `short + unsigned int` | `unsigned int`  | `short ‚Üí int ‚Üí unsigned int`            |

üìå Key fact:
If unsigned is involved, expect everything to become unsigned.


4. Assignment Conversion
=======================
Right-hand side is converted to the left-hand type.

| Code                   | Result                 |
| ---------------------- | ---------------------- |
| `int x = 3.9;`         | `x = 3` (truncate)     |
| `unsigned int u = -1;` | `u = UINT_MAX`         |
| `char c = 300;`        | Implementation-defined |

‚ö†Ô∏è NO warnings ‚â† safe

5. Comparison Conversion (Critical for Logic Bugs)
======================================================
int a = -1;
unsigned int b = 1;
if (a < b)   // FALSE

| Step                            | Value                    |
| ------------------------------- | ------------------------ |
| `a` converted to `unsigned int` | `4294967295`             |
| Compare                         | `4294967295 < 1` ‚Üí false |

This is not a compiler bug. This is your bug.


6. Variadic Functions (printf landmine)
=======================================
Default promotions apply:

| Passed Type | Actually Received |
| ----------- | ----------------- |
| `char`      | `int`             |
| `short`     | `int`             |
| `float`     | `double`          |

Mismatch = undefined behavior.
printf("%u", -1);   // WRONG but common


7. Summary Cheat Sheet (Memorize This)

| Situation         | Rule                        |
| ----------------- | --------------------------- |
| Small integers    | Promote to `int`            |
| Mixed float + int | Convert int to float        |
| Signed + unsigned | Signed becomes unsigned     |
| Assignment        | RHS ‚Üí LHS type              |
| Comparison        | Same conversion rules apply |
| `printf`          | Types must EXACTLY match    |

Brutal Reality Check

If you can‚Äôt:
predict the result of -20 + 10u
explain why %d vs %u changes output
spot logic bugs caused by signedness
