Type Conversions in C - Study Notes
Core Concepts
1. Implicit Type Conversions (Promotion)

    Rule: Smaller types automatically convert to larger types
    Hierarchy: char → int → long → float → double
    Example:

c

char c = 'A';  // c = 65
int x = 5;
int result = c + x;  // c converts to int first, then: 65 + 5 = 70

2. Character Arithmetic

    Key insight: Characters are just small integers
    ASCII values: '0'=48, '1'=49, ... '9'=57 (consecutive)
    Digit conversion: '5' - '0' = 53 - 48 = 5
    Case conversion: Uppercase + 32 = lowercase
        'A' (65) + 32 = 'a' (97)
        In code: c + 'a' - 'A' means c + 32

3. Signed ↔ Unsigned Conversion

    When negative becomes unsigned: Bit pattern stays same, interpretation changes
    Example:

c

int x = -1;              // Binary: 11111111111111111111111111111111
unsigned int y = x;      // Same bits, now means: 4,294,967,295
printf("%u", y);
OR
    int x = -1;

    // No need for a second variable
    printf("As signed: %d\n", x);   // Output: -1
    printf("As unsigned: %u\n", x); // Output: 4294967295 (on 32-bit)
\\When you pass a variable to printf, you are passing the raw binary data stored in that memory location.

When should you assign it to a new variable?
While you don't need it for printing, 
you would want to assign it to an unsigned int variable if you plan to do math or comparisons later in your program.
 eg. x <= y

If one operand is unsigned and the other is signed, and the unsigned type can represent all values of the signed type, 
the signed operand is converted to unsigned.

            //Exploit relevance: Negative numbers become huge positive numbers



4. Truncation (Bigger → Smaller Type)

    Rule: High-order bits are dropped
    Formula: result = value % (max_of_smaller_type + 1)
    Example:

c

int big = 300;           // Binary: 00000000 00000000 00000001 00101100
char small = big;        // Keeps only: 00101100 = 44
// Calculation: 300 % 256 = 44

Critical Exploit Pattern: Integer Overflow Bypass
The Vulnerability

Different type sizes in check vs use:
--------------------------------------
c

// Check function - uses small type (16-bit)
int check_size(unsigned short len) {
    return (len + 1 <= 256);  // 65535 + 1 wraps to 0
}

// Copy function - uses large type (64-bit)
void do_copy(char *src, size_t len) {
    char buffer[256];
    memcpy(buffer, src, len + 1);  // 65535 + 1 = 65536 (no wrap)
}

void vulnerable(char *src, unsigned short user_len) {
    if (check_size(user_len)) {      // Wraps, check passes
        do_copy(src, user_len);       // Doesn't wrap, overflow!
    }
}
```

### Attack with len = 65535:
1. **Check**: `65535 + 1` wraps to `0` (unsigned short, 16-bit) → `0 <= 256` ✓ passes
2. **Copy**: `65535` converts to `size_t` → `65535 + 1 = 65536` (no wrap) → **buffer overflow!** size_t is unsigned int

## Why Type Sizes Matter
```
unsigned short (16-bit): max = 65,535
    65535 + 1 = wraps to 0

size_t (64-bit): max = 18 quintillion  
    65535 + 1 = 65,536 (no wrap)

Same number, different type = different result
Key Takeaways for Exploit Dev
==============================
Integer Promotion Occurs
==============================
void process(unsigned char len) {
    char buf[200];
    
    if (len + 100 < 200) {
        memcpy(buf, data, len + 100);
    }
}


How many bytes does memcpy try to copy?


    Small type in security check → can wrap/overflow → bypass
    Large type in actual operation → doesn't wrap → triggers vulnerability
    Signed/unsigned mixing → negative becomes huge positive
    Truncation → predictable bit loss (use modulo to calculate)

Practice reminder: When analyzing code for vulnerabilities, always check if length calculations use different type sizes in checks vs actual operations.


#Subject: The mechanics of Bit Representations and Integer Comparisons
=======================================================================
Summary of Key Concepts:----------------
32-Bit Capacities:
-----------------
1. 2^{32} (4,294,967,296): The total number of unique values in a 32-bit space. It requires 33 bits to represent as a literal integer.
2. 2^{32}-1 (4,294,967,295): The maximum value of an unsigned int. In binary, this is 32 ones (0xFFFFFFFF).
The "Integer Promotion" Rule:
----------------------------
In C and C++, types smaller than int (like char and short) are automatically promoted to a signed 32-bit int before any calculation or comparison.
For example:
    unsigned char a = 200;
    unsigned char b = 100;
    printf("size of a is: %zd", sizeof(a));
    printf("\nsize of a is: %zd", sizeof(b));
    printf("\nSize of a+b is: %zd", sizeof(a+b));

1. Impact on s < i:  short (65535) and i is an int (-1), s is promoted to a positive 32-bit int.
2. The Result: The computer compares the mathematical values (int +65535 v/s int  -1). Therefore, 65535 < -1 is False (0).
Sign vs. Value Preservation:
----------------------------
1. Promotion to a signed type does not make a positive number negative. It simply moves the value into a larger "container" that is capable of handling signs.
2. 65535 promoted to 32-bit signed int stays +65535 (the sign bit remains 0).
The Comparison Paradox:
1. Small vs Large: unsigned short (16-bit) vs int (32-bit) → Promotes to int. Math is logically correct (65535 is not less than -1).
2. Equal Rank: unsigned int (32-bit) vs int (32-bit) → Promotes to unsigned. The -1 "wraps" to 4.2 billion. Math becomes bit-heavy (65535 IS less than 4.2 billion).
Technical Takeaway:
When debugging security checks or memory offsets, always remember that the compiler 
prioritizes mathematical value preservation for small types (char/short), 
but reverts to bit-level wrapping for full-sized int types.

Key Takeaway for Security :
If you are writing a security check (like if (size + 10 > buffer_size)), always use unsigned types. If you use signed types, 
the compiler may delete your if check entirely during optimization because it assumes size+10 will never mathematically be smaller than size. 

==========================
Bit promotions in addition
============================
char len = 200
(len + 100 < 200)
If len = 200, the memcpy will copy 0 bytes because it will never be executed. 
Here is the step-by-step breakdown of why: Integer Promotion: 

In the expression len + 100, the variable len is an unsigned char. In C, any integer type smaller than int (like char or short) is automatically promoted to a signed int before an arithmetic operation.
The Calculation:
len (200) is promoted to an int with the value 200.
The constant 100 is also an int.
The addition is performed in int logic: 200+100=300.

The Condition Check: The code checks if (len + 100 < 200).
In this case, the check is (300 < 200).
Since 300 is not less than 200, the condition is false.

Final Result: Because the if condition fails, the memcpy call inside the block is skipped entirely. No data is copied. 

What if there was no if check? If you called memcpy(buf, data, len + 100) directly with len = 200 without the if safety check, 
the third argument (which expects a size_t) would receive the value 300. This would cause a buffer overflow, as it would try to write 300 bytes into a 200-byte array (buf[200]).


The addition does not wrap around to 44 because of a rule in C called Integer Promotion. 
In C, arithmetic operations are never performed on types smaller than int. 
When you perform len + 100, the following happens: 
Promotion: The unsigned char len (value 200) is promoted to a signed int.
Calculation: The addition is performed using integer precision: 200 + 100 = 300.
Comparison: The condition evaluated is 300<200, which is false.

A wrap-around would only occur if you assigned the result back to an unsigned char before the comparison, like this:	
unsigned char sum = len + 100; // sum becomes 44
if (sum < 200) { ... }         // This would be true


e.g
//not vlunerable
                void process(unsigned char len) {
                    char buf[200];
    
                    if (len + 100 < 200) {
                        memcpy(buf, data, len + 100);
                            }
                        }
                    char len is 200;

//vulnerable
        f ((unsigned char)(len + 100) < 200)
